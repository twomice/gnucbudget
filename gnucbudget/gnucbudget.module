<?php

/**
 * @file
 * Module file for GnuCash Budgeting
 */

function gnucbudget_cron() {
  // On cron, take care of these tasks:
  // 1. import new gnucash accounts to GnuCash Account entities.
  _gnucbudget_sync_gnucash_accounts();
  // 2. import transactions/splits for GnuCash accounts having an Account entity.
  _gnucbudget_sync_gnucash_transactions();
  // 3. do "quick" balance calculation for all accounts.
  _gnucbudget_balance_accounts();
  // 4. If it's time, perform account resets.
  _gnucbudget_reset_accounts();
  // 5. If it's time, perform allotments.
  _gnucbudget_allot_accounts();
}

function gnucbudget_init() {
}

function _gnucbudget_balance_accounts() {
  $account_ids = _gnucbudget_get_budget_accounts_to_guids_map();
  foreach ($account_ids as $account_id) {
    _gnucbudget_balance_account($account_id);
  }
  dsm('FIXME: '. __FUNCTION__ . ' not complete.');
}

/**
 * Calculate the ending balance for a given account in all months up to the
 * current month, begining with a given month.
 * - If no month is given, or if $month is greater than current month, assume
 *   current month.
 * - If no balance record exists for the account in the month:
 *    - Set $month to the oldest month between $month and 'gnucbudget_balance_month_min'
 *      for which no balance record exists (this may be the current month or
 *      gnucbudget_balance_month_min).
 *    - If a balance record DOES NOT exist for the account in the immediately
 *      previous month, create a new balance record for the given month, with
 *      starting balance of 0.
 *    - Otherwise, perform account reset and allotment based on the previous
 *      month's ending balance, and create a balance record for the month with the
 *      appropriate starting balance (based on reset and allotments)
 * - From the month's starting balance, subtract all transactions for the account
 *   in the month, writing this difference to the ending balance.
 * - Mark all transactions for the account in the month as totalled.
 * - Delete any existing balance records for months following the given month.
 * - If current month is greater than $month, call this function again for the
 *   following month.
 *
 * @param Int $account_id Entity ID for an Account entity.
 * @param String $month A month in the form of 'YYYY-MM'; balancing will start
 *          from this month and continue to the current month.
 *
 * @return Boolean TRUE if all went well, otherwise FALSE.
 */
function _gnucbudget_balance_account($account_id, $month = '') {
  // If no month is given, or if $month is greater than current month, assume
  // current month.
  if (empty($month) || strtotime($month) > time()) {
    $month = date("Y-m");
  }
  $gnucbudget_balance_month_min = _gnucbudget_var_get('gnucbudget_balance_month_min');
  // If month is older than gnucbudget_balance_month_min, assume gnucbudget_balance_month_min
  if (strtotime($month) < strtotime($gnucbudget_balance_month_min)) {
    $month = $gnucbudget_balance_month_min;
  }

  
  dsm($month, 'month');
  // Find a balance record for account/month
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'balance')
    ->fieldCondition('field_month', 'value', "{$month}-01", '=');
  $results = $query->execute();
  if (!empty($results['balance'])) {
    // We found a balance record for this month and account.
    $balance_result = reset($results['balance']);
    $balance_id = $balance_result->id;
  }
  else {
    // Find balance record for most recent previous month, if any, as far back
    // as $gnucbudget_balance_month_min.
    $previous_balance = _gnucbudget_get_latest_balance($account_id, $month, $gnucbudget_balance_month_min);
    if (is_object($previous_balance)) {
      // We've a most recent balance record. Find out what month it's for.
      $items = field_get_items('balance', $previous_balance, 'field_month');
      $previous_balance_month = date('Y-m', strtotime($items[0]['value']));
      $items = field_get_items('balance', $previous_balance, 'field_ending_balance');
      $previous_balance_ending = date('Y-m', strtotime($items[0]['value']));

      // Create the next month's balance record.
      $month = date('Y-m', strtotime("$previous_balance_month +1 month"));
      $entity = entity_create('balance', array('type' => 'balance'));
      $entity->field_month = array(LANGUAGE_NONE => array(0 => array('value' => "{$month}-01")));
      $entity->field_account = array(LANGUAGE_NONE => array(0 => array('target_id' => $account_id)));
      $entity->field_starting_balance = array(LANGUAGE_NONE => array(0 => array('value' => $previous_balance_ending)));
      $entity->save();

      // Now we know which balance record to use.
      $balance_id = $entity->id;
    }
    else {
      // There is no balance record for this account, ever. Create one for
      // $gnucbudget_balance_month_min
      $month = $gnucbudget_balance_month_min;
      $entity = entity_create('balance', array('type' => 'balance'));
      $entity->field_month = array(LANGUAGE_NONE => array(0 => array('value' => "{$month}-01")));
      $entity->field_account = array(LANGUAGE_NONE => array(0 => array('target_id' => $account_id)));
      $entity->field_starting_balance = array(LANGUAGE_NONE => array(0 => array('value' => 0)));
      $entity->field_ending_balance = array(LANGUAGE_NONE => array(0 => array('value' => 0)));
      $entity->save();

      // Now we know which balance record to use.
      $balance_id = $entity->id;
    }
  }
  
  // Now we know which balance record to use. Apply resets and allotments for
  // this account/month, if none exist already.
  _gnucbudget_do_reset_and_allot($account_id, $month);

  // Total all transactions into this account
  // Total all transactions out of this account
  // Add to starting balance and set ending balance.

  // If this is a month in the past, clear certain data from all following months,
  // and calculate balance for next month.
  if (strtotime($month) < strtotime(date('Y-m'))) {
    $next_month = date('Y-m', strtotime("$month +1 month"));
    _gnucbudget_clear_account_future($account_id, $next_month);
    _gnucbudget_balance_account($account_id, $next_month);
  }
  // NEXT TODO: create basic english rules for balancing an account.
  dsm('FIXME: '. __FUNCTION__ . ' not complete.');
}

/**
 * For a given account and month, if there are no reset or allotment transactions,
 * perform them now.
 *
 * @param String $account_id
 * @param String $month A month in the form of 'YYYY-MM'
 */
function _gnucbudget_do_reset_and_allot($account_id, $month) {
  $needs_action = FALSE;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'transaction')
    ->fieldCondition('field_post_date', 'value', "{$month}-01", '>=')
    ->fieldCondition('field_transaction_type', 'value', array('reset'), '=');
  $results = $query->execute();
  if (empty($results['transaction'])) {
    $needs_action = TRUE;
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'transaction')
      ->fieldCondition('field_post_date', 'value', "{$month}-01", '>=')
      ->fieldCondition('field_transaction_type', 'value', array('allotment'), '=');
    $results = $query->execute();
    if (empty($results['transaction'])) {
      $needs_action = TRUE;
    }
  }
  if ($needs_action) {
    // First clear all reset and allotment transactions for this and future months.
    _gnucbudget_clear_account_future($account_id, $month);
    // Get general account ID.
    $general_account_id = _guncbudget_get_system_account_id('general');

    // Create reset transactions.
    $accounts = entity_load('account', array($account_id));
    $account = $account[$account_id];
    $items = field_get_items('account', $account, 'field_allotment');
    $allotment = floatval($items[0]['value']);
    $items = field_get_items('account', $account, 'field_reset_frequency_months');
    $reset_frequency_months = $items[0]['value'];

    $balance = _gnucbudget_get_latest_balance($account_id, $month);
    $items = field_get_items('balance', $balance, 'field_starting_balance');
    $starting_balance = $items[0]['value'];
    if ($field_reset_frequency_months == 1) {
      // First, move any excess balance into General.
      $zero_amount = ($starting_balance > 0 ? $starting_balance : 0);
      $entity = entity_create('transaction', array('type' => 'transaction'));
      $entity->field_from = array(LANGUAGE_NONE => array(0 => array('target_id' => $account_id)));
      $entity->field_to = array(LANGUAGE_NONE => array(0 => array('target_id' => $general_account_id)));
      $entity->field_post_date = array(LANGUAGE_NONE => array(0 => array('value' => "{$month}-01")));
      $entity->field_amount = array(LANGUAGE_NONE => array(0 => array('value' => $zero_amount)));
      $entity->field_transaction_type = array(LANGUAGE_NONE => array(0 => array('value' => 'reset')));
      $entity->save();

      // Credit any "reset" amount into the budget account.
      $items = field_get_items('account', $account, 'field_reset_factor');
      $reset_factor = floatval($items[0]['value']);
      $reset_amount = (($reset_factor && $allotment) ? ($reset_factor * $allotment) : $allotment);
      if ($reset_amount) {
        $entity = entity_create('transaction', array('type' => 'transaction'));
        $entity->field_from = array(LANGUAGE_NONE => array(0 => array('target_id' => $general_account_id)));
        $entity->field_to = array(LANGUAGE_NONE => array(0 => array('target_id' => $account_id)));
        $entity->field_post_date = array(LANGUAGE_NONE => array(0 => array('value' => "{$month}-01")));
        $entity->field_amount = array(LANGUAGE_NONE => array(0 => array('value' => $reset_amount)));
        $entity->field_transaction_type = array(LANGUAGE_NONE => array(0 => array('value' => 'reset')));
        $entity->save();
      }
    }
    // Create allotment transaction.
    $entity = entity_create('transaction', array('type' => 'transaction'));
    $entity->field_from = array(LANGUAGE_NONE => array(0 => array('target_id' => $general_account_id)));
    $entity->field_to = array(LANGUAGE_NONE => array(0 => array('target_id' => $account_id)));
    $entity->field_post_date = array(LANGUAGE_NONE => array(0 => array('value' => "{$month}-01")));
    $entity->field_amount = array(LANGUAGE_NONE => array(0 => array('value' => $allotment)));
    $entity->field_transaction_type = array(LANGUAGE_NONE => array(0 => array('value' => 'allotment')));
    $entity->save();
  }
  // Calculate total in
  // FIXME: refactor
  $sql = "
    SELECT
      a.entity_type, a.entity_id, a.field_amount_value, p.field_post_date_value, t.field_to_target_id
    FROM
        field_data_field_amount a
        INNER JOIN field_data_field_post_date p on p.entity_type = a.entity_type and p.entity_id = a.entity_id
        INNER JOIN field_revision_field_to t on t.entity_type = a.entity_type and t.entity_id = a.entity_id
    WHERE
      a.language = 'und'
      and p.language = 'und'
      and t.language = 'und'
  ";
  // Calculate total out
  $sql = "
    SELECT
      a.entity_type, a.entity_id, a.field_amount_value, p.field_post_date_value, f.field_from_target_id
    FROM
        field_data_field_amount a
        INNER JOIN field_data_field_post_date p on p.entity_type = a.entity_type and p.entity_id = a.entity_id
        INNER JOIN field_revision_field_from f on f.entity_type = a.entity_type and f.entity_id = a.entity_id
    WHERE
      a.language = 'und'
      and p.language = 'und'
      and f.language = 'und'
  ";

  $ending_balance = ($starting_balance + $total_in - $total_out);
}

/**
 * For a given account and month, delete all reset and allotment transactions.
 *
 * @param String $account_id The ID of the account entity to clear
 * @param String $month A month in the form of 'YYYY-MM'; all balances, reset
 *          transactions, and allotment transactions in this month and following
 *          months will be deleted.
 */
function _gnucbudget_clear_account_future($account_id, $month) {
  // Remove for FROM account.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'transaction')
    ->fieldCondition('field_from', 'value', $account_id, '=')
    ->fieldCondition('field_post_date', 'value', "{$month}-01", '>=')
    ->fieldCondition('field_transaction_type', 'value', array('reset', 'allotment'), 'IN');
  $results = $query->execute();
  if (!empty($results['transaction'])) {
    entity_delete_multiple('transaction', array_keys($results['transaction']));
  }
  // Remove for TO account.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'transaction')
    ->fieldCondition('field_to', 'value', $account_id, '=')
    ->fieldCondition('field_post_date', 'value', "{$month}-01", '>=')
    ->fieldCondition('field_transaction_type', 'value', array('reset', 'allotment'), 'IN');
  $results = $query->execute();
  if (!empty($results['transaction'])) {
    entity_delete_multiple('transaction', array_keys($results['transaction']));
  }
}

///**
// * For a given balance record, set the starting balance, taking into account
// * the previous month's ending balance, and account reset rules and allotments.
// * @param Objecct $balance Drupal balance entity object.
// *
// * @return The modified $balance entity object, or FALSE if something went wrong.
// */
//function _gnucbudget_set_starting_balance($balance) {
//  /**
//   * We have different situations here:
//   * 1. first month ever: no reset, just do allotments
//   * 2. subsequent month: reset based on previous month, then allotments
//   */
//
//
//
//  $items = field_get_items('balance', $balance, 'field_account');
//  $account_id = $items[0]['target_id'];
//  $items = field_get_items('balance', $balance, 'field_month');
//  $month = $items[0]['value'];
//  dsm($month, 'balance month');
//  $accounts = entity_load('account', array($account_id));
//  $account = $accounts[$account_id];
//
//  $previous_month = date('Y-m', strtotime("$month -1 month"));
//  $previous_balance = _gnucbudget_get_latest_balance($account_id, $previous_month);
//  if (is_null($previous_balance)) {
//    $args = array(
//      '%account' => $account_id,
//      '%month' => $month,
//    );
//    watchdog('gnucbudget', 'Could not set starting balance for account %account in month %month, because the previous month balance does not exist.', $args);
//    return FALSE;
//  }
//  dsm($previous_balance, '$previous_balance');
//  return $balance;
//
//}

/**
 * For a given account and month, get the balance entity object for the previous
 * month's balance.
 *
 * @param Int $account_id Entity ID for an Account entity.
 * @param String $max_month A month in the form of 'YYYY-MM'; newest month that
 *        may be returned.
 * @param Boolean $min_month Oldest month which may be returned, if NULL,
 *        "$max_month" is assumed.
 *
 * @return Balance entity if one is found, otherwise NULL.
 */
function _gnucbudget_get_latest_balance($account_id, $max_month, $min_month = NULL) {
  if (is_null($min_month)) {
    $min_month = $max_month;
  }
  dsm($min_month, '$min_month');
  dsm($max_month, '$max_month');
  $previous_balance = NULL;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'balance')
    ->fieldCondition('field_month', 'value', array("{$min_month}-01", "{$max_month}-01"), 'BETWEEN')
    ->fieldOrderBy('field_month', 'value', 'DESC');
  $results = $query->execute();
  if (!empty($results['balance'])) {
    $previous_balance_result = reset($results['balance']);
    $previous_balance_id = $previous_balance_result->id;
    $previous_balances = entity_load('balance', array($previous_balance_id));
    $previous_balance = $previous_balances[$previous_balance_id];
  }
  return $previous_balance;
}

function _gnucbudget_reset_accounts() {
  dsm('FIXME: '. __FUNCTION__ . ' not complete.');
}

function _gnucbudget_allot_accounts() {
  dsm('FIXME: '. __FUNCTION__ . ' not complete.');
}


/**
 * Get a module variable value.
 * FIXME: Currently using hard-coded variables. Change to using var_get() after
 * we've provided a settings form.
 *
 * @param String $key
 *
 * @return mixed The requested variable value.
 */
function _gnucbudget_var_get($key) {
  $vars = array(
    'gnucbudget_balance_month_min' => '2016-10',
    'gnucbudget_transaction_date_min' => '2016-12-01',
    'gnucbudget_transaction_history_months_max' => '6',
  );
  
  return $vars[$key];
}

function _gnucbudget_get_budget_accounts_to_guids_map() {
  static $accounts_to_guids_map;
  if (!isset($accounts_to_guids_map)) {
    $accounts_to_guids_map = array();
    $view_object = views_get_view('gnucbudget_budget_accounts_to_guids_map');
    $view_object->set_display("default");
    $view_object->pre_execute();
    $view_object->execute();
    $results = $view_object->result;
    foreach ($results as $result) {
      $accounts_to_guids_map[$result->field_field_gnucash_guid[0]['raw']['value']] = $result->id;
    }
  }
  return $accounts_to_guids_map;
}

function _guncbudget_get_system_account_id($type) {
  static $expense_account_id;
  if (!isset($expense_account_id)) {
    // Get ID of 'Expense' account
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'account')
      ->fieldCondition('field_type', 'value', $type, '=');
    $results = $query->execute();
    $expense_account = reset($results['account']);
    $expense_account_id = $expense_account->id;
  }
  return $expense_account_id;
}

function _gnucbudget_sync_gnucash_transactions() {
  // Get activities from gnucash database.
  for ($months_ago = _gnucbudget_var_get('gnucbudget_transaction_history_months_max'); $months_ago >= 0; $months_ago--) {
    $month = date("Y-m", strtotime("-$months_ago month"));
    _gnucbudget_sync_gnucash_transactions_month($month);
  }

}

function _gnucbudget_sync_gnucash_transactions_month($month) {
  db_set_active('gnucash');
  $query = db_select('transactions', 't');
  $query->join('splits', 's', "s.tx_guid = t.guid");
  $query->join('accounts', 'a', "s.account_guid = a.guid AND a.account_type = :type", array(':type' => 'EXPENSE'));
  $query->fields('s', array('account_guid'))
      ->fields('t', array('post_date', 'description', 'guid'))
      ->condition('t.post_date', _gnucbudget_var_get('gnucbudget_transaction_date_min'), '>=');
  $query->where("date_format(t.post_date, '%Y-%m') = :month", array(':month' => $month));
  $query->addExpression('round(s.value_num / s.value_denom, 2)', 'amount');
  $result = $query->execute();

  // We have to store this in an array, and then switch back to 'default' database
  // before manipulating Drupal entities based on this data.
  $rows = $result->fetchAll();
  db_set_active('default');

  if (!empty($rows)) {
    $accounts_to_guids_map = _gnucbudget_get_budget_accounts_to_guids_map();
    $expense_account_id = _guncbudget_get_system_account_id('expense');

    // Now create transaction entities for each fetched gnucash transaction, if
    // one doesn't already exist.
    foreach($rows as $row) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'transaction')
        ->fieldCondition('field_gnucash_guid', 'value', $row->guid, '=');
      $results = $query->execute();
      if (empty($results)) {
        $entity = entity_create('transaction', array('type' => 'transaction'));
        $entity->field_gnucash_guid = array(LANGUAGE_NONE => array(0 => array('value' => $row->guid)));
        $entity->field_from = array(LANGUAGE_NONE => array(0 => array('target_id' => $accounts_to_guids_map[$row->account_guid])));
        $entity->field_to = array(LANGUAGE_NONE => array(0 => array('target_id' => $expense_account_id)));
        $entity->field_description = array(LANGUAGE_NONE => array(0 => array('value' => $row->description)));
        $entity->field_post_date = array(LANGUAGE_NONE => array(0 => array('value' => $row->post_date)));
        $entity->field_amount = array(LANGUAGE_NONE => array(0 => array('value' => $row->amount)));
        $entity->field_transaction_type = array(LANGUAGE_NONE => array(0 => array('value' => 'gnucash')));
        $entity->save();
      }
    }
  }
}

function _gnucbudget_sync_gnucash_accounts() {
  db_set_active('gnucash');
  $result = db_select('accounts', 'a')
    ->fields('a', array('guid', 'name'))
    ->condition('account_type', 'EXPENSE')
    ->execute();
  // We have to store this in an array, and then switch back to 'default' database
  // before manipulating Drupal entities based on this data.
  $rows = $result->fetchAll();

  // Switch back to Drupal database, and create new gnucash_account entities as
  // needed for each fetched account.
  db_set_active('default');
  foreach ($rows as $row) {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'gnucash_account')
      ->fieldCondition('field_gnucash_guid', 'value', $row->guid, '=');
    $result = $query->execute();
    if (empty($result)) {
      $entity = entity_create('gnucash_account', array('type' => 'gnucash_account'));
      $entity->field_gnucash_guid = array(LANGUAGE_NONE => array(0 => array('value' => $row->guid)));
      $entity->title = $row->name;
      $entity->save();
    }
  }
}